import Matter, { Bodies, Body, Constraint, Engine, IBodyDefinition, Render, Runner, World, Vector, Composite } from 'matter-js';
import { GameObjectType } from './utils';

export const STARTING_BODY_ID = 666;

const TEMP_RENDER_WIDTH = 100;
const TEMP_RENDER_HEIGHT = 100;
const BOUNDARY_WIDTH = 40;
const ME_COLOR = 'white';

const SNAKE_HEAD_SIZE = 8;
const SNAKE_TAIL_SIZE = 6;
const FOOD_SIZE = 24;
const FOOD_COLOR = 'rgb(234, 123, 198)';

const snakeColors: Map<number, string> = new Map();

export class Physics {

  public engine: Engine;
  private runner: Runner | null = null;
  private render: Render;
  private tempRender: Render;

  private bottomBoundary: Body;
  private topBoundary: Body;
  private rightBoundary: Body;
  private leftBoundary: Body;

  // currently the - kind of hacky - way to reset the ids generated by the physic
  // error in types for matter-js, which apparently doesn't expose Matter.Common
  // hence casting to any
  private matterCommon: any = (Matter as any).Common;

  constructor(
    private element: HTMLElement,
    public width: number,
    public height: number,
  ) {
    // create an engine
    this.engine = Engine.create();
    this.engine.world.gravity = { x: 0, y: 0, scale: 0 };

    // create a renderer
    this.render = Render.create({
      element: this.element,
      engine: this.engine,
      options: {
        width: this.width,
        height: this.height,
        wireframes: false,
      },
    });

    // add hidden element to main element to give to temp renderer
    const hiddenEl = document.createElement('div');

    // create a temp renderer
    this.tempRender = Render.create({
      element: hiddenEl,
      engine: this.engine,
      options: {
        width: this.width,
        height: this.height,
        wireframes: false,
      },
    });

    this.bottomBoundary = Bodies.rectangle(
      this.width / 2,
      this.height + BOUNDARY_WIDTH / 2,
      this.width,
      BOUNDARY_WIDTH,
      { render: { visible: false }, isStatic: true, label: 'boundary' },
    );
    this.topBoundary = Bodies.rectangle(
      this.width / 2,
      0 - BOUNDARY_WIDTH / 2,
      this.width,
      BOUNDARY_WIDTH,
      { render: { visible: false }, isStatic: true, label: 'boundary' },
    );
    this.rightBoundary = Bodies.rectangle(
      this.width + BOUNDARY_WIDTH / 2,
      this.height / 2,
      BOUNDARY_WIDTH,
      this.height,
      { render: { visible: false }, isStatic: true, label: 'boundary' },
    );
    this.leftBoundary = Bodies.rectangle(
      0 - BOUNDARY_WIDTH / 2,
      this.height / 2,
      BOUNDARY_WIDTH,
      this.height,
      { render: { visible: false }, isStatic: true, label: 'boundary' },
    );

    World.add(this.engine.world, [this.bottomBoundary, this.topBoundary, this.leftBoundary, this.rightBoundary]);

    // make sure all our bodies start at this given id to not conflict with any other ids
    // absolutely not necessary because of matter-js.
    // we want to be able to start each generation with the ids we used in the last gen
    // the ids are given by matter-js so we trick matter-js by setting its internal pointer
    // to the next id we want our ids to start with
    // naturally you would set this to 0... but apparently matter-js places some things
    // on the world before you even start working on it. The starting id was always 5 for me.
    // to overcome this we start with an arbitrary (but higher than 5) number as our starting id.
    this.matterCommon._nextId = STARTING_BODY_ID;
  }

  getRandomSnake(): Composite {
    const randomPos = this.getRandomPosition();
    const snake = this.createSnakeBody(randomPos.x, randomPos.y, 10);
    return snake;
  }

  createSnakeBody(x: number, y: number, length: number): Composite {
    const snakeOptions: IBodyDefinition = {
      friction: 0,
      frictionAir: 0.05,
      density: 1,
      mass: 1,
      label: String(GameObjectType.SNAKE),
      collisionFilter: {
        group: Body.nextGroup(true),
      },
    }
    const head = Bodies.circle(x, y, SNAKE_HEAD_SIZE, { ...snakeOptions });

    const tail = [];
    const constraints = [];
    for (let i = 1; i <= length; i++) {
      const isFirst = i === 1;
      const incX = i * SNAKE_HEAD_SIZE * (isFirst ? 1.6 : 1.4);
      const incY = i * SNAKE_HEAD_SIZE * (isFirst ? 1.6 : 1.4);
      const tailPiece = Bodies.circle(x + incX, y - incY, SNAKE_TAIL_SIZE, {
        ...snakeOptions,
        label: 'snake-tail',
      });
      const constraint = Constraint.create({
        bodyA: isFirst ? head : tail[i - 2],
        bodyB: tailPiece,
        stiffness: 0.1,
        damping: 0.1,
        render: {
          visible: false,
          lineWidth: 0,
          strokeStyle: 'line',
        },
      });
      tail.push(tailPiece);
      constraints.push(constraint);
    }
    const snakeComposite = Composite.create({
      label: String(GameObjectType.SNAKE),
      bodies: [head, ...tail],
      constraints: constraints,
    });

    // get an existing snake color or add a random one
    let snakeColor = `rgb(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)})`;
    if (snakeColors.has(snakeComposite.id)) {
      snakeColor = snakeColors.get(snakeComposite.id) as string;
    } else {
      snakeColors.set(snakeComposite.id, snakeColor);
    }

    head.render.fillStyle = snakeColor;
    tail.forEach(tailPiece => tailPiece.render.fillStyle = snakeColor);

    return snakeComposite;
  }

  getRandomPosition(): Vector {
    const randomX = BOUNDARY_WIDTH * 3 + Math.random() * (this.width - BOUNDARY_WIDTH * 6);
    const randomY = BOUNDARY_WIDTH * 3 + Math.random() * (this.height - BOUNDARY_WIDTH * 6);
    return Vector.create(randomX, randomY);
  }

  getFood(x: number, y: number): Body {
    const food = this.createFood(x, y);
    return food;
  }

  createFood(x: number, y: number = 500): Body {
    return Bodies.circle(x, y, FOOD_SIZE, {
      label: String(GameObjectType.FOOD),
      friction: 0,
      frictionAir: 0.4,
      inertia: 0,
      render: {
        fillStyle: FOOD_COLOR,
        opacity: 1,
      },
    });
  }

  run() {
    console.log('[PHYSICS]: run()');
    // run the engine
    this.runner = Runner.run(this.engine);

    // run the renderer
    Render.run(this.render);
  }

  get snakesOnWorld(): Body[] {
    return this.engine.world.bodies.filter(body => body.label === String(GameObjectType.SNAKE));
  }

  stop() {
    console.log('[PHYSICS]: stop()');
    Render.stop(this.render);
    if (this.runner) {
      Runner.stop(this.runner);
    }
  }

  destroy() {
    console.log('[PHYSICS]: destroy()');
    World.clear(this.engine.world, true);
    this.matterCommon._nextId = STARTING_BODY_ID;
  }

  getImageData(): ImageData {

    let imgData: ImageData;
    if (this.render && this.render.canvas) {
      const context = this.render.canvas.getContext('2d');
      if (context) {
        const tempRenderContext = this.tempRender.canvas.getContext('2d');
        if (tempRenderContext) {
          tempRenderContext.clearRect(0, 0, this.width, this.height);
          tempRenderContext.drawImage(context.canvas, 0, 0, TEMP_RENDER_WIDTH, TEMP_RENDER_HEIGHT);
          imgData = tempRenderContext.getImageData(0, 0, TEMP_RENDER_WIDTH, TEMP_RENDER_HEIGHT);
        }
      }
    }
    return imgData!;
  }
}
